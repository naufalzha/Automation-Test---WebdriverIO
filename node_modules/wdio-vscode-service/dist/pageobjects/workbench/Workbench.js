"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Workbench = void 0;
const TitleBar_1 = require("../menu/TitleBar");
const SideBarView_1 = require("../sidebar/SideBarView");
const ActivityBar_1 = require("../activityBar/ActivityBar");
const StatusBar_1 = require("../statusBar/StatusBar");
const EditorView_1 = require("../editor/EditorView");
const BottomBarPanel_1 = require("../bottomBar/BottomBarPanel");
const Notification_1 = require("./Notification");
const Input_1 = require("./Input");
const SettingsEditor_1 = require("../editor/SettingsEditor");
const utils_1 = require("../utils");
const _1_61_0_1 = require("../../locators/1.61.0");
/**
 * Page object representing the custom VSCode title bar
 *
 * @category Workbench
 */
let Workbench = class Workbench extends utils_1.BasePage {
    constructor() {
        super(...arguments);
        /**
         * @private
         */
        this.locatorKey = 'Workbench';
    }
    /**
     * Get a title bar handle
     */
    getTitleBar() {
        return new TitleBar_1.TitleBar(this.locatorMap);
    }
    /**
     * Get a side bar handle
     */
    getSideBar() {
        return new SideBarView_1.SideBarView(this.locatorMap);
    }
    /**
     * Get an activity bar handle
     */
    getActivityBar() {
        return new ActivityBar_1.ActivityBar(this.locatorMap);
    }
    /**
     * Get a status bar handle
     */
    getStatusBar() {
        return new StatusBar_1.StatusBar(this.locatorMap);
    }
    /**
     * Get a bottom bar handle
     */
    getBottomBar() {
        return new BottomBarPanel_1.BottomBarPanel(this.locatorMap);
    }
    /**
     * Get a handle for the editor view
     */
    getEditorView() {
        return new EditorView_1.EditorView(this.locatorMap);
    }
    /**
     * Get all standalone notifications (notifications outside the notifications center)
     * @returns Promise resolving to array of Notification objects
     */
    async getNotifications() {
        const notifications = [];
        const containers = await this.notificationContainer$$;
        if (containers.length === 0) {
            return [];
        }
        for (const container of containers) {
            const elements = await container.$$(this.locators.notificationItem);
            for (const element of elements) {
                notifications.push(await new Notification_1.StandaloneNotification(this.locatorMap, 
                // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
                element).wait());
            }
        }
        return notifications;
    }
    /**
     * Verifies if any notifications are shown
     * @returns true if workbench has notifications, false otherwise
     */
    hasNotifications() {
        return this.notificationContainer$.isExisting();
    }
    /**
     * Opens the notifications center
     * @returns Promise resolving to NotificationsCenter object
     */
    openNotificationsCenter() {
        const statusBar = new StatusBar_1.StatusBar(this.locatorMap);
        return statusBar.openNotificationsCenter();
    }
    /**
     * Opens the settings editor
     *
     * @returns promise that resolves to a SettingsEditor instance
     */
    async openSettings() {
        await this.executeCommand('open user settings');
        await new EditorView_1.EditorView(this.locatorMap).openEditor('Settings');
        await this.elem.$(this.locatorMap.Editor.elem).waitForExist();
        await new Promise((res) => setTimeout(res, 500));
        return new SettingsEditor_1.SettingsEditor(this.locatorMap);
    }
    /**
     * Open the VS Code command line prompt
     * @returns Promise resolving to InputBox (vscode 1.44+) or QuickOpenBox (vscode up to 1.43) object
     */
    async openCommandPrompt() {
        const editorView = await new EditorView_1.EditorView(this.locatorMap).wait();
        const webview = await editorView.webView$$;
        if (webview.length > 0) {
            const tab = await editorView.getActiveTab();
            if (tab) {
                await tab.elem.addValue(['F1']);
                const inputBox = new Input_1.InputBox(this.locatorMap).wait();
                return inputBox;
            }
        }
        await browser.keys(['F1']);
        if (await browser.getVSCodeChannel() === 'vscode' && await browser.getVSCodeVersion() >= '1.44.0') {
            return new Input_1.InputBox(this.locatorMap).wait();
        }
        return new Input_1.QuickOpenBox(this.locatorMap).wait();
    }
    /**
     * Open the command prompt, type in a command and execute
     * @param command text of the command to be executed
     * @returns Promise resolving when the command prompt is confirmed
     */
    async executeCommand(command) {
        const prompt = await this.openCommandPrompt();
        await prompt.setText(`>${command}`);
        await prompt.confirm();
    }
};
Workbench = __decorate([
    (0, utils_1.PageDecorator)(_1_61_0_1.Workbench)
], Workbench);
exports.Workbench = Workbench;
//# sourceMappingURL=Workbench.js.map